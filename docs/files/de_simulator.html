<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DE (差分進化) シミュレータ</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 5px;
            background-color: #f0f0f0;
            overflow: hidden;
        }
        .container {
            width: 96vw;
            height: 96vh;
            margin: 0 auto;
            background-color: white;
            padding: 8px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: grid;
            grid-template-columns: 0.6fr 1.2fr 1.1fr;
            grid-template-rows: auto 1fr;
            gap: 10px;
            overflow: hidden;
            max-width: 1600px;
        }
        h1 {
            text-align: center;
            color: #333;
            margin: 5px 0;
            font-size: 20px;
            grid-column: 1 / -1;
        }
        .particle-table-wrapper {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 8px;
            overflow-y: auto;
            max-height: 650px;
        }
        .particle-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            border: 1px solid #000;
            table-layout: fixed;
        }
        .particle-table th {
            background-color: #f5e6d8;
            color: #000;
            padding: 6px 4px;
            text-align: center;
            font-weight: bold;
            line-height: 1.2;
            border: 1px solid #000;
        }
        .particle-table th:nth-child(1) {
            width: 18%;
        }
        .particle-table th:nth-child(2) {
            width: 35%;
        }
        .particle-table th:nth-child(3) {
            width: 23.5%;
        }
        .particle-table th:nth-child(4) {
            width: 23.5%;
        }
        .particle-table td {
            padding: 2px 4px;
            border: 1px solid #000;
            line-height: 1.2;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
        }
        .particle-table tr:nth-child(even) {
            background-color: #fff;
        }
        .particle-table tr:hover {
            background-color: #e8f0ff;
        }
        .particle-table .particle-id {
            font-weight: normal;
            color: #000;
        }
        .particle-table .value-cell {
            text-align: right;
            font-family: monospace;
        }
        .particle-table tr.gbest-row td {
            background-color: #ffff00 !important;
        }
        .particle-table tr.gbest-row:hover td {
            background-color: #ffd700 !important;
        }
        .particle-info-column {
            grid-row: 2;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .middle-column {
            grid-row: 2;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .right-column {
            grid-row: 2;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .canvas-wrapper {
            background-color: #fafafa;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 5px;
            display: flex;
            flex-direction: column;
        }
        .canvas-wrapper.visualization-3d {
            height: 100%;
        }
        .canvas-wrapper.visualization-2d {
            flex: 0 0 auto;
        }
        .canvas-wrapper h3 {
            margin: 2px 0;
            font-size: 14px;
            text-align: center;
        }
        canvas {
            display: block;
            margin: 0 auto;
            cursor: move;
        }
        .visualization-3d canvas {
            max-width: 100%;
            max-height: calc(100% - 30px);
        }
        .visualization-2d canvas {
            width: 100%;
            max-width: 400px;
        }
        .status-and-control {
            display: flex;
            flex-direction: column;
            gap: 0;
            background-color: #5872a8;
            border-radius: 5px;
            overflow: hidden;
        }
        .info-section, .control-section {
            padding: 10px 15px;
            color: white;
        }
        .info-section {
            padding: 5px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        .info-section h3, .control-section h3 {
            margin: 0 0 10px 0;
            color: white;
            font-size: 16px;
        }
        .status-table {
            width: 100%;
            border-collapse: collapse;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
        }
        .status-table td {
            padding: 5px 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 14px;
        }
        .status-table td:first-child {
            width: 60%;
        }
        .status-table td:last-child {
            width: 40%;
            text-align: center;
        }
        .controls {
            background-color: transparent;
            padding: 0;
            overflow-y: auto;
            max-height: 300px;
        }
        .controls h3 {
            display: none;
        }
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 0;
            margin-bottom: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 3px 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        label {
            font-weight: bold;
            color: #fff;
            font-size: 11px;
        }
        input[type="range"] {
            width: 100%;
        }
        .value-display {
            font-family: monospace;
            color: #ffffff;
            font-size: 11px;
        }
        .button-group {
            display: flex;
            gap: 5px;
            margin-top: 6px;
            flex-wrap: wrap;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 6px 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 11px;
            transition: background-color 0.3s;
            flex: 1;
            min-width: 50px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            color: white;
        }
        .info-item {
            display: flex;
            justify-content: space-between;
        }
        .info-item strong {
            color: #ffffff;
            font-weight: normal;
        }
        .info-item span {
            color: #f0f0f0;
        }
        .legend {
            margin-top: 5px;
            font-size: 12px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 3px;
        }
        .legend-color {
            width: 15px;
            height: 8px;
            border: 1px solid #999;
        }
        select {
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #aaa;
            font-size: 12px;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.9);
        }
        .formula-container {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            margin: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        .formula-title {
            font-weight: bold;
            color: #333;
            font-size: 14px;
            white-space: nowrap;
        }
        .formula-equation {
            font-size: 18px;
            color: #222;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DE (差分進化) シミュレータ</h1>
        
        <div class="particle-info-column">
            <div class="particle-table-wrapper">
                <h3 style="margin: 0 0 5px 0; font-size: 13px; color: #333;">個体情報</h3>
                <table class="particle-table" id="particleTable">
                    <thead>
                        <tr>
                            <th>個体<i>i</i></th>
                            <th>位置 <i>x<sub>i</sub></i></th>
                            <th><i>f</i>(<i>x<sub>i</sub></i>)</th>
                            <th><i>f</i>(<i>trial<sub>i</sub></i>)</th>
                        </tr>
                    </thead>
                    <tbody id="particleTableBody">
                        <!-- 個体データがここに挿入される -->
                    </tbody>
                </table>
            </div>
        </div>
        
        <div class="middle-column">
            <div class="canvas-wrapper visualization-3d">
                <h3>3Dグラフ</h3>
                <canvas id="canvas3d" width="500" height="500"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <span class="legend-color" style="background-color: #ff0000;"></span>
                        <span>個体</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background-color: #ffff00;"></span>
                        <span>最良個体(best)</span>
                    </div>
                    <div class="legend-item" id="trialLegend" style="display: none;">
                        <span class="legend-color" style="background-color: #00ff00;"></span>
                        <span>試行ベクトル(trial)</span>
                    </div>
                </div>
                <div id="functionFormula" style="margin-top: 10px; text-align: center; font-size: 16px; font-family: 'Times New Roman', serif;">
                    <!-- 数式がここに表示される -->
                </div>
            </div>
        </div>
        
        <div class="right-column">
            <div class="canvas-wrapper visualization-2d">
                <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 5px; font-size: 12px;">
                    <h3 style="margin: 0; font-size: 14px; margin-right: 15px;">2D等高線マップ</h3>
                    <div style="display: flex; gap: 15px;">
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <span style="display: inline-block; width: 15px; height: 10px; background: linear-gradient(to right, #00c800 0%, #32c8c8 50%, #96ffff 100%); border: 1px solid #666;"></span>
                            <span>低値(良)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <span style="display: inline-block; width: 15px; height: 10px; background: linear-gradient(to right, #b480c8 0%, #dc9ca0 50%, #ffff50 100%); border: 1px solid #666;"></span>
                            <span>高値(悪)</span>
                        </div>
                    </div>
                </div>
                <canvas id="canvas2d" width="400" height="400"></canvas>
            </div>
            
            <div class="status-and-control">
                <div class="info-section">
                <table class="status-table">
                    <tr>
                        <td id="statusLine">世代: 0, 最良値: 0.0000000, (x₁,x₂) = (0.0, 0.0)</td>
                        <td id="convergence">収束状態:初期化前</td>
                    </tr>
                </table>
                </div>
                
                <div class="control-section">
                <div class="controls">
                    <h3>パラメータ設定</h3>
                    
                    <div class="controls-grid">
                        <div class="control-group">
                            <label>目的関数:</label>
                            <select id="functionSelect">
                                <option value="sphere">Sphere関数</option>
                                <option value="rastrigin">Rastrigin関数</option>
                                <option value="rosenbrock">Rosenbrock関数</option>
                                <option value="ackley">Ackley関数</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <label>個体数:</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="range" id="populationSize" min="10" max="100" value="30" step="5" style="flex: 1;">
                                <span class="value-display" id="populationSizeValue" style="min-width: 30px; text-align: right;">30</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>スケーリング係数 (F):</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="range" id="scalingFactor" min="0.0" max="2.0" value="0.8" step="0.1" style="flex: 1;">
                                <span class="value-display" id="scalingFactorValue" style="min-width: 40px; text-align: right;">0.8</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>交叉率 (CR):</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="range" id="crossoverRate" min="0.0" max="1.0" value="0.9" step="0.05" style="flex: 1;">
                                <span class="value-display" id="crossoverRateValue" style="min-width: 30px; text-align: right;">0.90</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>変異戦略:</label>
                            <select id="mutationStrategy">
                                <option value="rand1">DE/rand/1/bin</option>
                                <option value="best1">DE/best/1/bin</option>
                                <option value="rand2">DE/rand/2/bin</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <label>アニメーション速度:</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="range" id="animationSpeed" min="1" max="100" value="5" style="flex: 1;">
                                <span class="value-display" id="animationSpeedValue" style="min-width: 30px; text-align: right;">5</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="button-group">
                        <button id="startBtn">開始</button>
                        <button id="pauseBtn" disabled>停止</button>
                        <button id="resetBtn">リセット</button>
                        <button id="stepBtn">1ステップ</button>
                        <button id="trialToggleBtn" style="background-color: #888;">trial表示</button>
                    </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        try {
            // グローバル変数
            let population = [];
            let globalBest = null;
            let generation = 0;
            let animationId = null;
            let isRunning = false;
            let showTrial = false; // 試行ベクトルの表示フラグ
            let trialVectors = []; // 現在の試行ベクトル
            
            // キャンバス要素
            const canvas3d = document.getElementById('canvas3d');
            const ctx3d = canvas3d.getContext('2d');
            const canvas2d = document.getElementById('canvas2d');
            const ctx2d = canvas2d.getContext('2d');
            
            // 3D表示用の変数
            let rotationX = -0.5;
            let rotationZ = 0.3;
            let isDragging = false;
            let lastMouseX = 0;
            let lastMouseY = 0;
            
            // 目的関数の定義
            const objectiveFunctions = {
                sphere: {
                    evaluate: (x, y) => x*x + y*y,
                    range: [-5, 5],
                    optimal: [0, 0]
                },
                rastrigin: {
                    evaluate: (x, y) => 20 + x*x + y*y - 10*(Math.cos(2*Math.PI*x) + Math.cos(2*Math.PI*y)),
                    range: [-1.5, 1.5],
                    optimal: [0, 0]
                },
                rosenbrock: {
                    evaluate: (x, y) => 100*(y - x*x)*(y - x*x) + (1 - x)*(1 - x),
                    range: [-2, 2],
                    optimal: [1, 1]
                },
                ackley: {
                    evaluate: (x, y) => {
                        const a = 20, b = 0.2, c = 2 * Math.PI;
                        return -a * Math.exp(-b * Math.sqrt(0.5 * (x*x + y*y))) - 
                               Math.exp(0.5 * (Math.cos(c*x) + Math.cos(c*y))) + a + Math.exp(1);
                    },
                    range: [-5, 5],
                    optimal: [0, 0]
                }
            };
            
            // 現在選択されている目的関数
            let currentFunction = objectiveFunctions.sphere;
            
            // 個体クラス
            class Individual {
                constructor(range) {
                    this.position = {
                        x: Math.random() * (range[1] - range[0]) + range[0],
                        y: Math.random() * (range[1] - range[0]) + range[0]
                    };
                    this.fitness = currentFunction.evaluate(this.position.x, this.position.y);
                    this.trial = null; // 試行ベクトル
                    this.trialFitness = null;
                }
                
                // DEの変異操作
                mutate(population, F, strategy, bestIndex) {
                    const range = currentFunction.range;
                    let mutant = {x: 0, y: 0};
                    
                    if (strategy === 'rand1') {
                        // DE/rand/1
                        let r1, r2, r3;
                        do {
                            r1 = Math.floor(Math.random() * population.length);
                            r2 = Math.floor(Math.random() * population.length);
                            r3 = Math.floor(Math.random() * population.length);
                        } while (r1 === r2 || r2 === r3 || r3 === r1);
                        
                        mutant.x = population[r1].position.x + F * (population[r2].position.x - population[r3].position.x);
                        mutant.y = population[r1].position.y + F * (population[r2].position.y - population[r3].position.y);
                    } else if (strategy === 'best1') {
                        // DE/best/1
                        let r1, r2;
                        do {
                            r1 = Math.floor(Math.random() * population.length);
                            r2 = Math.floor(Math.random() * population.length);
                        } while (r1 === r2);
                        
                        mutant.x = population[bestIndex].position.x + F * (population[r1].position.x - population[r2].position.x);
                        mutant.y = population[bestIndex].position.y + F * (population[r1].position.y - population[r2].position.y);
                    } else if (strategy === 'rand2') {
                        // DE/rand/2
                        let r1, r2, r3, r4, r5;
                        do {
                            r1 = Math.floor(Math.random() * population.length);
                            r2 = Math.floor(Math.random() * population.length);
                            r3 = Math.floor(Math.random() * population.length);
                            r4 = Math.floor(Math.random() * population.length);
                            r5 = Math.floor(Math.random() * population.length);
                        } while (r1 === r2 || r2 === r3 || r3 === r4 || r4 === r5 || r5 === r1);
                        
                        mutant.x = population[r1].position.x + F * (population[r2].position.x - population[r3].position.x) + F * (population[r4].position.x - population[r5].position.x);
                        mutant.y = population[r1].position.y + F * (population[r2].position.y - population[r3].position.y) + F * (population[r4].position.y - population[r5].position.y);
                    }
                    
                    return mutant;
                }
                
                // 交叉操作
                crossover(mutant, CR) {
                    const trial = {x: this.position.x, y: this.position.y};
                    const jrand = Math.floor(Math.random() * 2); // 確実に少なくとも1つの次元は変異する
                    
                    if (Math.random() < CR || jrand === 0) {
                        trial.x = mutant.x;
                    }
                    if (Math.random() < CR || jrand === 1) {
                        trial.y = mutant.y;
                    }
                    
                    // 境界処理
                    const range = currentFunction.range;
                    trial.x = Math.max(range[0], Math.min(range[1], trial.x));
                    trial.y = Math.max(range[0], Math.min(range[1], trial.y));
                    
                    this.trial = trial;
                    this.trialFitness = currentFunction.evaluate(trial.x, trial.y);
                    
                    return trial;
                }
                
                // 選択操作
                select() {
                    if (this.trialFitness !== null && this.trialFitness < this.fitness) {
                        this.position = {...this.trial};
                        this.fitness = this.trialFitness;
                    }
                }
            }
            
            // 2D等高線マップの描画（PSOと同じ）
            function draw2DContour() {
                const width = canvas2d.width;
                const height = canvas2d.height;
                
                // まず背景をクリア
                ctx2d.fillStyle = 'white';
                ctx2d.fillRect(0, 0, width, height);
                
                // 描画エリアのマージンを設定
                const marginLeft = 45;
                const marginBottom = 35;
                const marginRight = 20;
                const marginTop = 20;
                const plotWidth = width - marginLeft - marginRight;
                const plotHeight = height - marginBottom - marginTop;
                
                const imageData = ctx2d.createImageData(plotWidth, plotHeight);
                const data = imageData.data;
                
                const range = currentFunction.range;
                const rangeSize = range[1] - range[0];
                
                // 関数値の最大・最小を求める
                let minVal = Infinity, maxVal = -Infinity;
                for (let py = 0; py < plotHeight; py += 5) {
                    for (let px = 0; px < plotWidth; px += 5) {
                        const x = (px / plotWidth) * rangeSize + range[0];
                        const y = ((plotHeight - py - 1) / plotHeight) * rangeSize + range[0];
                        const val = currentFunction.evaluate(x, y);
                        minVal = Math.min(minVal, val);
                        maxVal = Math.max(maxVal, val);
                    }
                }
                
                // 等高線マップを描画
                for (let py = 0; py < plotHeight; py++) {
                    for (let px = 0; px < plotWidth; px++) {
                        const x = (px / plotWidth) * rangeSize + range[0];
                        const y = ((plotHeight - py - 1) / plotHeight) * rangeSize + range[0];
                        const val = currentFunction.evaluate(x, y);
                        
                        // 値を0-1に正規化（対数スケール）
                        const normalizedVal = Math.log(val - minVal + 1) / Math.log(maxVal - minVal + 1);
                        
                        // カラーマップ（緑→青緑→青→紫→黄）- より淡い色調
                        const idx = (py * plotWidth + px) * 4;
                        if (normalizedVal < 0.2) {
                            const t = normalizedVal / 0.2;
                            data[idx] = Math.floor(50 * t);
                            data[idx + 1] = Math.floor(200 - 50 * t);
                            data[idx + 2] = Math.floor(100 + 100 * t);
                        } else if (normalizedVal < 0.4) {
                            const t = (normalizedVal - 0.2) / 0.2;
                            data[idx] = Math.floor(50 + 50 * t);
                            data[idx + 1] = Math.floor(150 - 50 * t);
                            data[idx + 2] = Math.floor(200 + 30 * t);
                        } else if (normalizedVal < 0.6) {
                            const t = (normalizedVal - 0.4) / 0.2;
                            data[idx] = Math.floor(100 + 80 * t);
                            data[idx + 1] = Math.floor(100 - 20 * t);
                            data[idx + 2] = Math.floor(230 - 30 * t);
                        } else if (normalizedVal < 0.8) {
                            const t = (normalizedVal - 0.6) / 0.2;
                            data[idx] = Math.floor(180 + 40 * t);
                            data[idx + 1] = Math.floor(80 + 80 * t);
                            data[idx + 2] = Math.floor(200 - 40 * t);
                        } else {
                            const t = (normalizedVal - 0.8) / 0.2;
                            data[idx] = Math.floor(220 + 35 * t);
                            data[idx + 1] = Math.floor(160 + 95 * t);
                            data[idx + 2] = Math.floor(160 - 80 * t);
                        }
                        data[idx + 3] = 255;
                    }
                }
                
                ctx2d.putImageData(imageData, marginLeft, marginTop);
                
                // 個体を描画
                population.forEach(individual => {
                    const px = ((individual.position.x - range[0]) / rangeSize) * plotWidth + marginLeft;
                    const py = marginTop + plotHeight - ((individual.position.y - range[0]) / rangeSize) * plotHeight;
                    
                    ctx2d.fillStyle = 'red';
                    ctx2d.beginPath();
                    ctx2d.arc(px, py, 3, 0, 2 * Math.PI);
                    ctx2d.fill();
                    
                    // 試行ベクトルを描画
                    if (showTrial && individual.trial) {
                        const trialPx = ((individual.trial.x - range[0]) / rangeSize) * plotWidth + marginLeft;
                        const trialPy = marginTop + plotHeight - ((individual.trial.y - range[0]) / rangeSize) * plotHeight;
                        
                        ctx2d.fillStyle = 'lime';
                        ctx2d.beginPath();
                        ctx2d.arc(trialPx, trialPy, 2, 0, 2 * Math.PI);
                        ctx2d.fill();
                        
                        // 現在位置から試行ベクトルへの線
                        ctx2d.strokeStyle = 'rgba(0, 150, 255, 0.6)';
                        ctx2d.lineWidth = 1;
                        ctx2d.beginPath();
                        ctx2d.moveTo(px, py);
                        ctx2d.lineTo(trialPx, trialPy);
                        ctx2d.stroke();
                    }
                });
                
                // 最良個体を描画
                if (globalBest) {
                    const px = ((globalBest.position.x - range[0]) / rangeSize) * plotWidth + marginLeft;
                    const py = marginTop + plotHeight - ((globalBest.position.y - range[0]) / rangeSize) * plotHeight;
                    
                    ctx2d.strokeStyle = 'yellow';
                    ctx2d.lineWidth = 3;
                    ctx2d.beginPath();
                    ctx2d.arc(px, py, 3, 0, 2 * Math.PI);
                    ctx2d.stroke();
                }
                
                // 座標軸を描画
                ctx2d.strokeStyle = 'black';
                ctx2d.lineWidth = 1;
                ctx2d.font = '14px Arial';
                ctx2d.fillStyle = 'black';
                
                // X軸（下部）
                ctx2d.beginPath();
                ctx2d.moveTo(marginLeft, marginTop + plotHeight);
                ctx2d.lineTo(marginLeft + plotWidth, marginTop + plotHeight);
                ctx2d.stroke();
                
                // Y軸（左側）
                ctx2d.beginPath();
                ctx2d.moveTo(marginLeft, marginTop);
                ctx2d.lineTo(marginLeft, marginTop + plotHeight);
                ctx2d.stroke();
                
                // X軸のメモリと数値
                const functionName = document.getElementById('functionSelect').value;
                const xSteps = (functionName === 'rosenbrock') ? 8 : 5;
                for (let i = 0; i <= xSteps; i++) {
                    const x = marginLeft + plotWidth * i / xSteps;
                    const value = range[0] + rangeSize * i / xSteps;
                    
                    // メモリ
                    ctx2d.beginPath();
                    ctx2d.moveTo(x, marginTop + plotHeight);
                    ctx2d.lineTo(x, marginTop + plotHeight + 5);
                    ctx2d.stroke();
                    
                    // 数値
                    ctx2d.textAlign = 'center';
                    ctx2d.fillText(value.toFixed(1), x, marginTop + plotHeight + 15);
                }
                
                // Y軸のメモリと数値
                const ySteps = (functionName === 'rosenbrock') ? 8 : 5;
                for (let i = 0; i <= ySteps; i++) {
                    const y = marginTop + plotHeight * i / ySteps;
                    const value = range[1] - rangeSize * i / ySteps;
                    
                    // メモリ
                    ctx2d.beginPath();
                    ctx2d.moveTo(marginLeft - 5, y);
                    ctx2d.lineTo(marginLeft, y);
                    ctx2d.stroke();
                    
                    // 数値
                    ctx2d.textAlign = 'right';
                    ctx2d.fillText(value.toFixed(1), marginLeft - 7, y + 3);
                }
                
                // 軸ラベル
                ctx2d.textAlign = 'center';
                ctx2d.fillText('x₁', width / 2, height - 10);
                ctx2d.save();
                ctx2d.translate(15, marginTop + plotHeight / 2);
                ctx2d.rotate(-Math.PI / 2);
                ctx2d.fillText('x₂', 0, 0);
                ctx2d.restore();
            }
            
            // 3D表示の描画（基本的にPSOと同じだが、個体と試行ベクトルを描画）
            function draw3D() {
                ctx3d.fillStyle = '#f0f0f0';
                ctx3d.fillRect(0, 0, canvas3d.width, canvas3d.height);
                
                const centerX = canvas3d.width / 2;
                const functionName = document.getElementById('functionSelect').value;
                // 関数ごとに異なるY位置を設定
                let centerY = canvas3d.height / 2 + 65;
                if (functionName === 'rastrigin') {
                    centerY += 30;
                } else if (functionName === 'sphere') {
                    centerY += 20;
                } else if (functionName === 'ackley') {
                    centerY += 35;
                }
                // 関数ごとに異なるスケールを設定
                let scale = 35;
                if (functionName === 'sphere') {
                    scale = 50;
                } else if (functionName === 'rosenbrock') {
                    scale = 110;
                } else if (functionName === 'rastrigin') {
                    scale = 140;
                }
                const range = currentFunction.range;
                
                // 関数ごとに最適なグリッドサイズを設定
                let gridSize = 40;
                if (functionName === 'rastrigin') {
                    gridSize = 80;
                } else if (functionName === 'ackley') {
                    gridSize = 100;
                }
                const step = (range[1] - range[0]) / gridSize;
                
                // 高さの最大値を求める
                let minHeight = Infinity, maxHeight = -Infinity;
                for (let i = 0; i <= gridSize; i++) {
                    for (let j = 0; j <= gridSize; j++) {
                        const x = range[0] + i * step;
                        const y = range[0] + j * step;
                        const h = currentFunction.evaluate(x, y);
                        minHeight = Math.min(minHeight, h);
                        maxHeight = Math.max(maxHeight, h);
                    }
                }
                
                // 座標軸を描画
                const axisLength = range[1] - range[0];
                
                // X軸（赤）
                ctx3d.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                ctx3d.lineWidth = 2;
                ctx3d.beginPath();
                const xStart = project3Dto2D(range[0], 0, 0);
                const xEnd = project3Dto2D(range[1], 0, 0);
                ctx3d.moveTo(centerX + xStart.x * scale, centerY - xStart.y * scale);
                ctx3d.lineTo(centerX + xEnd.x * scale, centerY - xEnd.y * scale);
                ctx3d.stroke();
                
                // Y軸（緑）
                ctx3d.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                ctx3d.beginPath();
                const yStart = project3Dto2D(0, range[0], 0);
                const yEnd = project3Dto2D(0, range[1], 0);
                ctx3d.moveTo(centerX + yStart.x * scale, centerY - yStart.y * scale);
                ctx3d.lineTo(centerX + yEnd.x * scale, centerY - yEnd.y * scale);
                ctx3d.stroke();
                
                // Z軸（青）
                ctx3d.strokeStyle = 'rgba(0, 0, 255, 0.8)';
                ctx3d.beginPath();
                const zStart = project3Dto2D(0, 0, 0);
                const zEnd = project3Dto2D(0, 0, (functionName === 'sphere') ? 5.0 : (functionName === 'ackley') ? 9.0 : (functionName === 'rastrigin') ? 3.0 : 3.0);
                ctx3d.moveTo(centerX + zStart.x * scale, centerY - zStart.y * scale);
                ctx3d.lineTo(centerX + zEnd.x * scale, centerY - zEnd.y * scale);
                ctx3d.stroke();
                
                // 軸ラベル
                ctx3d.font = '16px Arial';
                ctx3d.fillStyle = 'red';
                const xLabel = project3Dto2D(range[1] + 0.5, 0, 0);
                ctx3d.fillText('x₁', centerX + xLabel.x * scale, centerY - xLabel.y * scale);
                
                ctx3d.fillStyle = 'green';
                const yLabel = project3Dto2D(0, range[1] + 0.5, 0);
                ctx3d.fillText('x₂', centerX + yLabel.x * scale, centerY - yLabel.y * scale);
                
                ctx3d.fillStyle = 'blue';
                const zLabel = project3Dto2D(0, 0, (functionName === 'sphere') ? 5.5 : (functionName === 'ackley') ? 9.5 : (functionName === 'rastrigin') ? 3.5 : 3.5);
                ctx3d.fillText('f', centerX + zLabel.x * scale, centerY - zLabel.y * scale);
                
                // ワイヤーフレームで描画（線のみ）
                ctx3d.strokeStyle = 'rgba(100, 100, 100, 0.5)';
                ctx3d.lineWidth = 0.5;
                
                // X方向のグリッド線
                for (let i = 0; i <= gridSize; i++) {
                    ctx3d.beginPath();
                    for (let j = 0; j <= gridSize; j++) {
                        const x = range[0] + i * step;
                        const y = range[0] + j * step;
                        const h = currentFunction.evaluate(x, y);
                        const z = (h - minHeight) / (maxHeight - minHeight) * ((functionName === 'sphere') ? 5.0 : (functionName === 'ackley') ? 9.0 : (functionName === 'rastrigin') ? 3.0 : 3.0);
                        const point = project3Dto2D(x, y, z);
                        
                        if (j === 0) {
                            ctx3d.moveTo(centerX + point.x * scale, centerY - point.y * scale);
                        } else {
                            ctx3d.lineTo(centerX + point.x * scale, centerY - point.y * scale);
                        }
                    }
                    ctx3d.stroke();
                }
                
                // Y方向のグリッド線
                for (let j = 0; j <= gridSize; j++) {
                    ctx3d.beginPath();
                    for (let i = 0; i <= gridSize; i++) {
                        const x = range[0] + i * step;
                        const y = range[0] + j * step;
                        const h = currentFunction.evaluate(x, y);
                        const z = (h - minHeight) / (maxHeight - minHeight) * ((functionName === 'sphere') ? 5.0 : (functionName === 'ackley') ? 9.0 : (functionName === 'rastrigin') ? 3.0 : 3.0);
                        const point = project3Dto2D(x, y, z);
                        
                        if (i === 0) {
                            ctx3d.moveTo(centerX + point.x * scale, centerY - point.y * scale);
                        } else {
                            ctx3d.lineTo(centerX + point.x * scale, centerY - point.y * scale);
                        }
                    }
                    ctx3d.stroke();
                }
                
                // 個体を描画
                population.forEach(individual => {
                    const h = currentFunction.evaluate(individual.position.x, individual.position.y);
                    const z = (h - minHeight) / (maxHeight - minHeight) * ((functionName === 'sphere') ? 5.0 : (functionName === 'ackley') ? 9.0 : (functionName === 'rastrigin') ? 3.0 : 3.0);
                    const point = project3Dto2D(individual.position.x, individual.position.y, z);
                    
                    ctx3d.fillStyle = 'red';
                    ctx3d.strokeStyle = 'darkred';
                    ctx3d.lineWidth = 1;
                    ctx3d.beginPath();
                    ctx3d.arc(centerX + point.x * scale, centerY - point.y * scale, 4, 0, 2 * Math.PI);
                    ctx3d.fill();
                    ctx3d.stroke();
                    
                    // 試行ベクトルを描画
                    if (showTrial && individual.trial) {
                        const trialH = currentFunction.evaluate(individual.trial.x, individual.trial.y);
                        const trialZ = (trialH - minHeight) / (maxHeight - minHeight) * ((functionName === 'sphere') ? 5.0 : (functionName === 'ackley') ? 9.0 : (functionName === 'rastrigin') ? 3.0 : 3.0);
                        const trialPoint = project3Dto2D(individual.trial.x, individual.trial.y, trialZ);
                        
                        ctx3d.fillStyle = 'lime';
                        ctx3d.strokeStyle = 'green';
                        ctx3d.lineWidth = 1;
                        ctx3d.beginPath();
                        ctx3d.arc(centerX + trialPoint.x * scale, centerY - trialPoint.y * scale, 3, 0, 2 * Math.PI);
                        ctx3d.fill();
                        ctx3d.stroke();
                        
                        // 現在位置から試行ベクトルへの線
                        ctx3d.strokeStyle = 'rgba(0, 150, 255, 0.6)';
                        ctx3d.lineWidth = 1;
                        ctx3d.beginPath();
                        ctx3d.moveTo(centerX + point.x * scale, centerY - point.y * scale);
                        ctx3d.lineTo(centerX + trialPoint.x * scale, centerY - trialPoint.y * scale);
                        ctx3d.stroke();
                    }
                });
                
                // 最良個体を描画
                if (globalBest) {
                    const h = currentFunction.evaluate(globalBest.position.x, globalBest.position.y);
                    const z = (h - minHeight) / (maxHeight - minHeight) * ((functionName === 'sphere') ? 5.0 : (functionName === 'ackley') ? 9.0 : (functionName === 'rastrigin') ? 3.0 : 3.0);
                    const point = project3Dto2D(globalBest.position.x, globalBest.position.y, z);
                    
                    ctx3d.fillStyle = 'yellow';
                    ctx3d.strokeStyle = 'orange';
                    ctx3d.lineWidth = 2;
                    ctx3d.beginPath();
                    ctx3d.arc(centerX + point.x * scale, centerY - point.y * scale, 5, 0, 2 * Math.PI);
                    ctx3d.fill();
                    ctx3d.stroke();
                }
            }
            
            // 3D座標を2Dに投影
            function project3Dto2D(x, y, z) {
                // Y軸周りの回転
                const x1 = x * Math.cos(rotationZ) - y * Math.sin(rotationZ);
                const y1 = x * Math.sin(rotationZ) + y * Math.cos(rotationZ);
                
                // X軸周りの回転
                const y2 = y1 * Math.cos(rotationX) - z * Math.sin(rotationX);
                const z2 = y1 * Math.sin(rotationX) + z * Math.cos(rotationX);
                
                return { x: x1, y: y2 };
            }
            
            // 数式を更新する関数
            function updateFormulaDisplay() {
                const functionName = document.getElementById('functionSelect').value;
                const formulaDiv = document.getElementById('functionFormula');
                
                const formulas = {
                    sphere: `
                        <div class="formula-container">
                            <span class="formula-title">Sphere関数</span>
                            <span class="formula-equation">
                                <i>f</i>(<i>x</i><sub>1</sub> ⋯ <i>x</i><sub><i>n</i></sub>) = <span style="display: inline-block; text-align: center; vertical-align: middle; line-height: 1.0;"><span style="display: block; font-size: 0.7em; margin-bottom: -0.2em;"><i>n</i></span><span style="display: block; font-size: 1.5em;">∑</span><span style="display: block; font-size: 0.7em; margin-top: 0.05em;"><i>i</i>=1</span></span> <i>x</i><sub><i>i</i></sub><sup>2</sup>
                            </span>
                        </div>
                    `,
                    rastrigin: `
                        <div class="formula-container">
                            <span class="formula-title">Rastrigin関数</span>
                            <span class="formula-equation">
                                <i>f</i>(<i>x</i><sub>1</sub> ⋯ <i>x</i><sub><i>n</i></sub>) = 10<i>n</i> + <span style="display: inline-block; text-align: center; vertical-align: middle; line-height: 1.0;"><span style="display: block; font-size: 0.7em; margin-bottom: -0.2em;"><i>n</i></span><span style="display: block; font-size: 1.5em;">∑</span><span style="display: block; font-size: 0.7em; margin-top: 0.05em;"><i>i</i>=1</span></span> [<i>x</i><sub><i>i</i></sub><sup>2</sup> - 10cos(2π<i>x</i><sub><i>i</i></sub>)]
                            </span>
                        </div>
                    `,
                    rosenbrock: `
                        <div class="formula-container">
                            <span class="formula-title">Rosenbrock関数</span>
                            <span class="formula-equation">
                                <i>f</i>(<i>x</i><sub>1</sub> ⋯ <i>x</i><sub><i>n</i></sub>) = <span style="display: inline-block; text-align: center; vertical-align: middle; line-height: 1.0;"><span style="display: block; font-size: 0.7em; margin-bottom: -0.2em;"><i>n</i>-1</span><span style="display: block; font-size: 1.5em;">∑</span><span style="display: block; font-size: 0.7em; margin-top: 0.05em;"><i>i</i>=1</span></span> [100(<i>x</i><sub><i>i</i>+1</sub> - <i>x</i><sub><i>i</i></sub><sup>2</sup>)<sup>2</sup> + (1 - <i>x</i><sub><i>i</i></sub>)<sup>2</sup>]
                            </span>
                        </div>
                    `,
                    ackley: `
                        <div class="formula-container">
                            <span class="formula-title">Ackley関数</span>
                            <span class="formula-equation" style="text-align: left;">
                                <i>f</i>(<i>x</i><sub>1</sub> ⋯ <i>x</i><sub><i>n</i></sub>) = -20exp(-0.2√(1/<i>n</i> <span style="display: inline-block; text-align: center; vertical-align: middle; line-height: 1.0;"><span style="display: block; font-size: 0.7em; margin-bottom: -0.2em;"><i>n</i></span><span style="display: block; font-size: 1.5em;">∑</span><span style="display: block; font-size: 0.7em; margin-top: 0.05em;"><i>i</i>=1</span></span> <i>x</i><sub><i>i</i></sub><sup>2</sup>))<br>
                                <span style="margin-left: 2.5em;">- exp(1/<i>n</i> <span style="display: inline-block; text-align: center; vertical-align: middle; line-height: 1.0;"><span style="display: block; font-size: 0.7em; margin-bottom: -0.2em;"><i>n</i></span><span style="display: block; font-size: 1.5em;">∑</span><span style="display: block; font-size: 0.7em; margin-top: 0.05em;"><i>i</i>=1</span></span> cos(2π<i>x</i><sub><i>i</i></sub>)) + 20 + <i>e</i></span>
                            </span>
                        </div>
                    `
                };
                
                formulaDiv.innerHTML = formulas[functionName] || '';
            }
            
            // DE初期化
            function initializeDE() {
                const populationSize = parseInt(document.getElementById('populationSize').value);
                population = [];
                
                // 数式を更新
                updateFormulaDisplay();
                
                // 関数ごとに初期角度を調整
                const functionName = document.getElementById('functionSelect').value;
                if (functionName === 'rosenbrock') {
                    rotationX = -0.3;
                    rotationZ = -0.8;
                } else if (functionName === 'rastrigin') {
                    rotationX = -1.0;
                    rotationZ = 0.7;
                } else {
                    rotationX = -0.5;
                    rotationZ = 0.3;
                }
                
                for (let i = 0; i < populationSize; i++) {
                    population.push(new Individual(currentFunction.range));
                }
                
                // 最良個体の初期化
                updateGlobalBest();
                
                generation = 0;
                updateInfo();
            }
            
            // 最良個体を更新
            function updateGlobalBest() {
                let bestIndex = 0;
                let bestFitness = population[0].fitness;
                
                for (let i = 1; i < population.length; i++) {
                    if (population[i].fitness < bestFitness) {
                        bestFitness = population[i].fitness;
                        bestIndex = i;
                    }
                }
                
                globalBest = {
                    position: {...population[bestIndex].position},
                    value: bestFitness,
                    individualIndex: bestIndex
                };
            }
            
            // DEの1ステップ実行
            function stepDE() {
                const F = parseFloat(document.getElementById('scalingFactor').value);
                const CR = parseFloat(document.getElementById('crossoverRate').value);
                const strategy = document.getElementById('mutationStrategy').value;
                
                // 最良個体のインデックスを取得
                let bestIndex = 0;
                for (let i = 1; i < population.length; i++) {
                    if (population[i].fitness < population[bestIndex].fitness) {
                        bestIndex = i;
                    }
                }
                
                // 各個体に対して変異、交叉、選択を実行
                population.forEach((individual, index) => {
                    // 変異
                    const mutant = individual.mutate(population, F, strategy, bestIndex);
                    
                    // 交叉
                    individual.crossover(mutant, CR);
                });
                
                // 選択（全個体の試行ベクトルが生成された後）
                population.forEach(individual => {
                    individual.select();
                });
                
                // 最良個体を更新
                updateGlobalBest();
                
                generation++;
                updateInfo();
                draw3D();
                draw2DContour();
                
                // 最良値が1e-6を下回ったら自動停止
                if (globalBest.value < 1e-6) {
                    isRunning = false;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('pauseBtn').disabled = true;
                    if (animationId) {
                        clearTimeout(animationId);
                    }
                    document.getElementById('convergence').textContent = '収束完了（最適解に到達）';
                    document.getElementById('convergence').style.color = '#90EE90';
                }
            }
            
            // 個体テーブルの更新
            function updateParticleTable() {
                const tbody = document.getElementById('particleTableBody');
                tbody.innerHTML = '';
                
                population.forEach((individual, index) => {
                    const row = document.createElement('tr');
                    
                    // bestかどうかチェック
                    if (globalBest && globalBest.individualIndex === index) {
                        row.className = 'gbest-row';
                    }
                    
                    row.innerHTML = `
                        <td class="particle-id">個体${index + 1}</td>
                        <td class="value-cell">(${individual.position.x.toFixed(1)}, ${individual.position.y.toFixed(1)})</td>
                        <td class="value-cell">${individual.fitness.toFixed(3)}</td>
                        <td class="value-cell">${individual.trialFitness !== null ? individual.trialFitness.toFixed(3) : '-'}</td>
                    `;
                    
                    tbody.appendChild(row);
                });
            }
            
            // 情報更新
            function updateInfo() {
                if (globalBest) {
                    const statusText = `世代: ${generation}<br>最良値: ${globalBest.value.toFixed(7)}, (x₁,x₂) = (${globalBest.position.x.toFixed(1)}, ${globalBest.position.y.toFixed(1)})`;
                    document.getElementById('statusLine').innerHTML = statusText;
                    
                    // 収束判定
                    if (globalBest.value < 1e-6) {
                        document.getElementById('convergence').textContent = '収束状態:収束（最適解に到達）';
                        document.getElementById('convergence').style.color = '#90EE90';
                    } else if (globalBest.value < 1e-3) {
                        document.getElementById('convergence').textContent = '収束状態:収束中';
                        document.getElementById('convergence').style.color = '#ffa500';
                    } else {
                        document.getElementById('convergence').textContent = '収束状態:探索中';
                        document.getElementById('convergence').style.color = '#ffffff';
                    }
                } else {
                    document.getElementById('statusLine').innerHTML = `世代: ${generation}<br>最良値: 0.0000000, (x₁,x₂) = (0.0, 0.0)`;
                }
                
                // 個体テーブルを更新
                updateParticleTable();
            }
            
            // アニメーションループ
            function animate() {
                if (isRunning) {
                    stepDE();
                    const speed = parseInt(document.getElementById('animationSpeed').value);
                    animationId = setTimeout(() => requestAnimationFrame(animate), 1000 / speed);
                }
            }
            
            // イベントリスナー
            document.getElementById('startBtn').addEventListener('click', () => {
                if (population.length === 0) {
                    initializeDE();
                }
                isRunning = true;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
                animate();
            });
            
            document.getElementById('pauseBtn').addEventListener('click', () => {
                isRunning = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
                if (animationId) {
                    clearTimeout(animationId);
                }
            });
            
            document.getElementById('resetBtn').addEventListener('click', () => {
                isRunning = false;
                if (animationId) {
                    clearTimeout(animationId);
                }
                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
                initializeDE();
                draw3D();
                draw2DContour();
            });
            
            document.getElementById('stepBtn').addEventListener('click', () => {
                if (population.length === 0) {
                    initializeDE();
                }
                stepDE();
            });
            
            document.getElementById('functionSelect').addEventListener('change', (e) => {
                // 実行を停止
                isRunning = false;
                if (animationId) {
                    clearTimeout(animationId);
                }
                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
                
                // 新しい関数に切り替えてリセット
                currentFunction = objectiveFunctions[e.target.value];
                updateFormulaDisplay();
                initializeDE();
                draw3D();
                draw2DContour();
            });
            
            // スライダーの値表示更新
            ['populationSize', 'scalingFactor', 'crossoverRate', 'animationSpeed'].forEach(id => {
                const slider = document.getElementById(id);
                const display = document.getElementById(id + 'Value');
                slider.addEventListener('input', () => {
                    let value = slider.value;
                    if (id === 'scalingFactor') {
                        value = parseFloat(value).toFixed(1);
                    } else if (id === 'crossoverRate') {
                        value = parseFloat(value).toFixed(2);
                    }
                    display.textContent = value;
                });
            });
            
            // 3Dビューのマウス操作
            canvas3d.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });
            
            canvas3d.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;
                    
                    rotationZ += deltaX * 0.01;
                    rotationX += deltaY * 0.01;
                    
                    rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotationX));
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    
                    draw3D();
                }
            });
            
            canvas3d.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            canvas3d.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            
            // trial表示トグルボタン
            document.getElementById('trialToggleBtn').addEventListener('click', () => {
                showTrial = !showTrial;
                const btn = document.getElementById('trialToggleBtn');
                if (showTrial) {
                    btn.style.backgroundColor = '#4CAF50';
                    document.getElementById('trialLegend').style.display = 'flex';
                } else {
                    btn.style.backgroundColor = '#888';
                    document.getElementById('trialLegend').style.display = 'none';
                }
                draw3D();
                draw2DContour();
            });
            
            // 初期描画
            initializeDE();
            updateFormulaDisplay();
            draw3D();
            draw2DContour();
            
        } catch (error) {
            console.error('エラーが発生しました:', error);
            alert('エラーが発生しました。コンソールを確認してください。');
        }
    </script>
</body>
</html>